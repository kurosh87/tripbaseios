//
//  BackendFunctions.swift
//  BackendKit (Generated by SwiftyLaunch 1.5.0)
//  https://docs.swiftylaun.ch/module/backendkit
//

import AnalyticsKit
import FirebaseFunctions
import Foundation
import SharedKit

public struct FetchedUser: Codable {
	let userID: String
	let username: String
	let postsCreated: Int
	let userHasPremium: Bool

	init(from rawData: [String: Any]) throws {
		guard JSONSerialization.isValidJSONObject(rawData),
			let data = try? JSONSerialization.data(withJSONObject: rawData),
			let decodedResults = try? JSONDecoder().decode(Self.self, from: data)
		else {
			throw NSError(domain: "Invalid Init Object", code: 0, userInfo: nil)
		}
		self = decodedResults
	}
}

// MARK: - Backend Functions Examples
extension DB {

	public func fetchAllBackendUsers() async -> [FetchedUser] {
		Analytics.capture(.info, id: "fetch_all_backend_users_called", source: .db)
		do {
			let data = try await functions.httpsCallable("fetchAllUsers").call()

			guard let usersRaw = data.data as? [[String: Any]] else {
				Analytics.capture(
					.error, id: "fetch_all_backend_users",
					longDescription: "Data Mismatch: data is not an array.", source: .db)
				showInAppNotification(
					.error,
					content: .init(title: "Server Error", message: "Error casting Server Data to App Data"))
				return []
			}

			let users = usersRaw.map({ try? FetchedUser(from: $0) })

			//Check if all of them are valid
			guard let fetchedUsers = users as? [FetchedUser] else {
				Analytics.capture(
					.error, id: "fetch_all_backend_users",
					longDescription: "Data Mismatch: couldn't map to user object.", source: .db)
				showInAppNotification(
					.error,
					content: .init(title: "Server Error", message: "Error casting Server Data to App Data"))
				return []
			}

			Analytics.capture(
				.success, id: "fetch_all_backend_users", longDescription: "Fetched \(fetchedUsers.count)",
				source: .db)
			return fetchedUsers
		} catch {
			debugPrint(error)
			Analytics.capture(
				.error, id: "fetch_all_backend_users",
				longDescription: "Error fetching users: \(error.localizedDescription)", source: .db)
			showInAppNotification(
				.error, content: .init(title: "Server Error", message: "Error fetching Users from the Database"))
			return []
		}
	}

	public func sendNotificationTo(userID: String, message: String) async {
		Analytics.capture(.info, id: "send_notification_to_called", longDescription: "To: \(userID)", source: .notif)
		do {
			var contentDict: [String: Any] = ["userID": userID]
			contentDict["message"] = message
			let _ = try await functions.httpsCallable("sendNotificationTo").call(contentDict)
		} catch {
			Analytics.capture(
				.error, id: "send_notification_to",
				longDescription: "Error sending notification: \(error.localizedDescription)", source: .notif)
			showInAppNotification(
				.error, content: .init(title: "Server Error", message: "Error Sending Notification to User"))
		}
	}

	/// We want to use this object to showcase messages within our app
	/// In other cases, we could share the same object as a received object and the object that we used in our app
	/// Meaning: We get an Object from a server (in JSON format) that we can then cast to a Swift Object (thus the decodable on other objects)
	/// This works great, except for one variable: timestamp. JSON famously doesn't support Dates, so we have to first transform it to a string on the server
	/// Then receive it here as a string and then convert it into an AIChatMessage object
	/// So, we have two initializers: one internal and the other one that is used in the fetchAIChatHistory() function.
	/// The fetchAIChatHistory one: is used to transform the rawData into temporary "ServerReceivedResultType" Object (same object as AIChatMessage, but the Date is a string)
	/// We then take the ServerReceivedResultType and transform it into AIChatMessage via the private init.
	// https://docs.swiftylaun.ch/module/aikit/ai-chat-example
	public struct AIChatMessage: Identifiable {

		public let id: String  //id in database
		public let isFromUser: Bool  // true if from user, false if from GPT
		public let messageContent: String  // the actual message
		public let timestamp: Date  // when the message was sent

		// Type that we receive from the server (that we then will use to construct AIChatMessage)
		private struct ServerReceivedResultType: Codable {
			let id: String
			let isFromUser: Bool
			let messageContent: String
			let timestamp: String  // received as iso string
		}

		private init(serverReceivedResult: ServerReceivedResultType) throws {
			self.id = serverReceivedResult.id
			self.isFromUser = serverReceivedResult.isFromUser
			self.messageContent = serverReceivedResult.messageContent
			guard let timestamp = convertJSONISOStringToDate(serverReceivedResult.timestamp) else {
				throw NSError(domain: "Invalid Date", code: 0, userInfo: nil)
			}
			self.timestamp = timestamp
		}

		init(from rawData: [String: Any]) throws {

			guard JSONSerialization.isValidJSONObject(rawData),
				let data = try? JSONSerialization.data(withJSONObject: rawData),
				let decodedServerResult = try? JSONDecoder().decode(ServerReceivedResultType.self, from: data)
			else {
				throw NSError(domain: "Invalid Init Object", code: 0, userInfo: nil)
			}

			// then we convert the ServerReceivedType to AIChatMessage
			self = try Self(serverReceivedResult: decodedServerResult)
		}

		// Just for general use (used to create a temporary, optimistic message in sendNewMessage in the AIChatExampleViewModel)
		public init(isFromUser: Bool, messageContent: String) {
			self.id = UUID().uuidString
			self.isFromUser = isFromUser
			self.messageContent = messageContent
			self.timestamp = Date()
		}
	}

	// https://docs.swiftylaun.ch/module/aikit/ai-chat-example#fetching-ai-chat-history
	public func fetchAIChatHistory() async -> [AIChatMessage] {
		Analytics.capture(.info, id: "fetch_ai_chat_history_called", source: .aikit)
		do {
			let data = try await functions.httpsCallable("retrieveCurrentUsersAIChatMessages").call()

			guard let messagesRaw = data.data as? [[String: Any]] else {
				Analytics.capture(
					.error, id: "fetch_ai_chat_history",
					longDescription: "Data Mismatch: data is not an array.", source: .aikit)
				showInAppNotification(
					.error,
					content: .init(title: "Server Error", message: "Error casting Server Data to App Data"))
				return []
			}

			Analytics.capture(.success, id: "fetch_ai_chat_history", source: .aikit)
			return try messagesRaw.map({ try AIChatMessage(from: $0) })
		} catch {
			Analytics.capture(
				.error, id: "fetch_ai_chat_history",
				longDescription: "Error fetching AI Chat History: \(error.localizedDescription)", source: .aikit)
			showInAppNotification(
				.error, content: .init(title: "Server Error", message: "Error fetching Messages from the DB"))
			return []
		}
	}

	// https://docs.swiftylaun.ch/module/aikit/ai-chat-example#deleting-the-chat-history
	public func deleteAIChatHistory() async -> Bool {
		Analytics.capture(.info, id: "delete_ai_chat_history_called", source: .aikit)
		do {
			let data = try await functions.httpsCallable("clearAIChatHistoryForCurrentUser").call()

			guard let result = data.data as? Bool else {
				Analytics.capture(
					.error, id: "delete_ai_chat_history",
					longDescription: "Data Mismatch: data is not a bool.", source: .aikit)
				return false
			}
			Analytics.capture(.success, id: "delete_ai_chat_history", source: .aikit)
			return result
		} catch {
			Analytics.capture(
				.error, id: "delete_ai_chat_history",
				longDescription: "Error deleting AI Chat History: \(error.localizedDescription)", source: .aikit)
			return false
		}
	}

	/// Will return new chat messages to append to current chat history
	// https://docs.swiftylaun.ch/module/aikit/ai-chat-example#sending-a-new-message-and-receiving-a-response
	public func sendNewAIChatMessage(text: String) async -> [AIChatMessage] {
		Analytics.capture(.info, id: "send_new_ai_chat_msg_called", source: .aikit)
		do {
			let contentDict: [String: Any] = ["text": text]
			let data = try await functions.httpsCallable("sendANewAIChatMessageForCurrentUser").call(contentDict)

			guard let messagesRaw = data.data as? [[String: Any]] else {
				Analytics.capture(
					.error, id: "send_new_ai_chat_msg",
					longDescription: "Data Mismatch: data is not an array.", source: .aikit)
				showInAppNotification(
					.error,
					content: .init(title: "Server Error", message: "Error casting Server Data to App Data"))
				return []
			}

			return try messagesRaw.map({ try AIChatMessage(from: $0) })
		} catch {
			Analytics.capture(
				.error, id: "send_new_ai_chat_msg",
				longDescription: "Error sending new AI Chat Message: \(error.localizedDescription)",
				source: .aikit)
			showInAppNotification(
				.error, content: .init(title: "Server Error", message: "Error sending message to AI"))
			return []
		}
	}
}

/// Will convert a JSON ISO String to a Date object, Refer to the Backend Code.
private func convertJSONISOStringToDate(_ isoString: String) -> Date? {
	let dateFormatter = DateFormatter()
	dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZ"
	dateFormatter.locale = Locale.current  // Setting to current user's locale
	return dateFormatter.date(from: isoString)
}
